!function e(r,n,o){function t(i,l){if(!n[i]){if(!r[i]){var s="function"==typeof require&&require;if(!l&&s)return s(i,!0);if(a)return a(i,!0);var c=new Error("Cannot find module '"+i+"'");throw c.code="MODULE_NOT_FOUND",c}var f=n[i]={exports:{}};r[i][0].call(f.exports,(function(e){return t(r[i][1][e]||e)}),f,f.exports,e,r,n,o)}return n[i].exports}for(var a="function"==typeof require&&require,i=0;i<o.length;i++)t(o[i]);return t}({1:[function(e,r,n){"use strict";function o(e,r,n){var o=e.createShader(r);if(e.shaderSource(o,n),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS))return o;console.log(e.getShaderInfoLog(o)),e.deleteShader(o)}n.main=function(e,r,n){var t=e.getContext("webgl");if(t){var a=function(e,r,n){var o=e.createProgram();if(e.attachShader(o,r),e.attachShader(o,n),e.linkProgram(o),e.getProgramParameter(o,e.LINK_STATUS))return o;console.log(e.getProgramInfoLog(o)),e.deleteProgram(o)}(t,o(t,t.VERTEX_SHADER,r),o(t,t.FRAGMENT_SHADER,n)),i=t.getAttribLocation(a,"a_position"),l=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,l);t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,0,.5,.7,0]),t.STATIC_DRAW),function(e,r){r=r||1;const n=e.clientWidth*r|0,o=e.clientHeight*r|0;(e.width!==n||e.height!==o)&&(e.width=n,e.height=o)}(t.canvas),t.viewport(0,0,t.canvas.width,t.canvas.height),t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.useProgram(a),t.enableVertexAttribArray(i),t.bindBuffer(t.ARRAY_BUFFER,l);var s=t.FLOAT,c=0;t.vertexAttribPointer(i,2,s,!1,0,c);var f=t.TRIANGLES;c=0;t.drawArrays(f,c,3)}}},{}],2:[function(e,r,n){const o=e("./blah.js");new Promise((function(e,r){window.onload=e})).then(()=>{const e=document.querySelectorAll("#c");window.globalShow=()=>{console.log("Hello")},window.globalHide=()=>{console.log("Hello Hide")},o.main(e[0],"\n// an attribute will receive data from a buffer\nattribute vec4 a_position;\n\n// all shaders have a main function\nvoid main() {\n\n  // gl_Position is a special variable a vertex shader\n  // is responsible for setting\n  gl_Position = a_position;\n}\n","\n// fragment shaders don't have a default precision so we need\n// to pick one. mediump is a good default\nprecision mediump float;\n\nvoid main() {\n  // gl_FragColor is a special variable a fragment shader\n  // is responsible for setting\n  gl_FragColor = vec4(1, 0, 0.5, 1); // return redish-purple\n}\n"),console.log(e)})},{"./blah.js":1}]},{},[2]);
//# sourceMappingURL=app.js.map
